\section{Encrypted Messages}\label{sec:veil.mres}

\texttt{veil.mres} implements a multi-recipient signcryption scheme.

\subsection{Encrypting A Message}\label{subsec:veil.mres-encrypt}

Encrypting a message is described in full in Alg.~\ref{alg:veil.mres-encrypt}.

\begin{algorithm}[ht]
    \caption{
        Encrypting a message with sender's key pair $(d_S, Q_S)$, receiver public keys $Q_{R^0}..Q_{R^n}$, padding
        length $N_P$, and plaintext $P$.
    }
    \begin{algorithmic}
        \Function{EncryptMessage}{$(d_S, Q_S), Q_{R^0}..Q_{R^n}, N_P, P$}
            \State \Call{Cyclist}{\texttt{veil.mres}, $\epsilon$, $\epsilon$}\Comment{Initialize duplex with constant key.}
            \State \Call{Absorb}{$Q_S$}\label{alg:veil.mres-encrypt-bind-sender}\Comment{Absorb the sender's public key.}
            \State
            \Clone \Comment{Clone the duplex's state.}
            \State \Call{Absorb}{$d_S$}\Comment{Absorb the sender's private key.}
            \State $v \rgets \allbits{512}$\Comment{Generate a random value.}
            \State \Call{Absorb}{$v$}\Comment{Absorb the random value.}
            \State $k \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze a commitment scalar.}
            \State $d_E \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze an ephemeral private key.}
            \State $K \gets$ \Call{Squeeze}{$32$}\Comment{Squeeze a data encryption key.}
            \State \textbf{yield} $(k, d_E, K)$
            \End
            \State
            \State $Q_E = [d_E]G$\Comment{Calculate the ephemeral public key.}
            \State $C \gets $\Call{PointToUniform}{$Q_E$}\Comment{Encode the key with Elligator2.}
            \State \Call{Absorb}{$C$}\Comment{Absorb the encoded public key.}
            \State
            \State $H = K||N_Q||N_P$\Comment{Encode the DEK and params in a header.}
            \ForAll{$Q_{R^i} \in \{Q_{R^0}..Q_{R^n}\}$}
                \Comment{Encrypt the header for each receiver.}
                \State $D \gets$\Call{Squeeze}{$16$}
                \State $H \gets $\Call{EncryptHeader}{$(d_S, Q_S), (d_E, Q_E), Q_{R^i}, H, D$}
                \State \Call{Absorb}{$H$}
                \State $C \gets C||H$
            \EndFor
            \State
            \State $y \rgets \allbits{N_P}$\Comment{Absorb and append random padding.}
            \ForAll{$y_i \in y$}
                \State \Call{Absorb}{$y_i$}\Comment{Absorb padding in 32KiB blocks.}
            \EndFor
            \State $C \gets C||y$
            \State
            \State \Call{Cyclist}{$K$, $\epsilon$, $\epsilon$}\Comment{Re-key the duplex with the DEK.}
            \ForAll{32-KiB blocks $p \in P$}
                \State $C \gets C||$\Call{Encrypt}{$p$}\Comment{Encrypt and tag each block.}
                \State $C \gets C||$\Call{Squeeze}{$16$}
                \State \Call{Ratchet}{}
            \EndFor
            \State
            \State $I \gets [k]G$\Comment{Calculate and encrypt the commitment point.}
            \State $C \gets C||$\Call{Encrypt}{$I$}
            \State
            \State $r \gets$ \Call{Squeeze}{$64$} $\modl$\label{alg:veil.mres-encrypt-challenge}\Comment{Squeeze a challenge scalar.}
            \State $s \gets {d_S}r + k$\Comment{Calculate and encrypt the proof scalar.}
            \State $C \gets C||$\Call{Encrypt}{$s$}
            \State \textbf{return} $C$
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.mres-encrypt}
\end{algorithm}

\subsection{Decrypting A Message}\label{subsec:veil.mres-decrypt}

Decrypting a signature is described in full in Alg.~\ref{alg:veil.mres-decrypt}.

\begin{algorithm}[ht]
    \caption{
        Decrypting a message with receiver's key pair $(d_R, Q_R)$, sender's public key $Q_S$, and ciphertext $C$.
    }
    \begin{algorithmic}
        \Function{DecryptMessage}{$(d_R, Q_R), Q_S, C$}
            \State \Call{Cyclist}{\texttt{veil.mres}, $\epsilon$, $\epsilon$}\Comment{Initialize duplex with constant key.}
            \State \Call{Absorb}{$Q_S$}\label{alg:veil.mres-decrypt-bind-sender}\Comment{Absorb the sender's public key.}
            \State
            \State \Call{Absorb}{$C[0..32]$}\Comment{Absorb the encoded ephemeral public key.}
            \State $Q_E \gets $\Call{UniformToPoint}{$C[0..32]$}\Comment{Decode the ephemeral public key.}
            \State
            \ForAll{possible encrypted headers $h \in C$}
                \State $D \gets$\Call{Squeeze}{$16$}
                \State $x \gets $ \Call{DecryptHeader}{$(d_R, Q_R), Q_S, Q_E, h, D$}
                \If{$x \not= \bot$}
                    \State $K || N_Q || N_P \gets x$
                \EndIf
                \State \Call{Absorb}{$h$}
            \EndFor
            \State
            \ForAll{$y_i \in C[32+N_Q..32+N_Q+N_P]$}
                \State \Call{Absorb}{$y_i$}\Comment{Absorb padding in 32KiB blocks.}
            \EndFor
            \State $C \gets C[{32+N_Q+N_P}..]$\Comment{Skip to the message beginning.}
            \State
            \State \Call{Cyclist}{$K$, $\epsilon$, $\epsilon$}\Comment{Re-key the duplex with the DEK.}
            \State
            \State $P' = \epsilon$\Comment{Initialize a buffer for the plaintext.}
            \ForAll{32KiB+16 blocks $c||t \in C$}
                \State $P' \gets P'||$\Call{Decrypt}{$c$}
                \If{\Call{Squeeze}{$16$} $ \not= t$}
                    \Comment{Check each block's tag.}
                    \State \textbf{return} $\bot$
                \EndIf
                \State \Call{Ratchet}{}
            \EndFor
            \State
            \State $S_0||S_1 \gets C$
            \State $I \gets $ \Call{Decrypt}{$S_0$}\Comment{Decrypt the commitment point.}
            \State $r \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze a challenge scalar.}
            \State
            \State $s \gets $ \Call{Decrypt}{$S_1$}\Comment{Decrypt the proof scalar.}
            \State $I' \gets [s]G - [r]Q_E$\Comment{Calculate the counterfactual commitment point.}
            \State
            \If{$I' \checkeq I$}
                \Comment{Verify the signature.}
                \State \textbf{return} $P'$ \Comment{Return the plaintext.}
            \Else
                \State \textbf{return} $\bot$
            \EndIf
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.mres-decrypt}
\end{algorithm}

\subsection{Constructive Analysis Of \texttt{veil.mres}}\label{subsec:veil.mres-analysis}

\texttt{veil.mres} is an integration of two well-known constructions: a multi-recipient hybrid encryption scheme and an
EdDSA-style Schnorr signature scheme.

The initial portion of \texttt{veil.mres} is a multi-recipient hybrid encryption scheme, with per-receiver copies of a
symmetric data encryption key (DEK) encrypted in headers with the receivers' public
keys~\cite{kurosawa2002, bellare2003, bellare2007, rfc4880}.
The headers are encrypted with the \texttt{veil.sres} construction (see~\ref{sec:veil.sres}), which provides full
insider security (i.e.\ IND-CCA2 and sUF-CMA in the multi-user insider setting), using a per-header \textsc{Squeeze}
value as a nonce.
The message itself is divided into a sequence of 32KiB blocks, each encrypted with a sequence of Xoodyak
\textsc{Encrypt}/\textsc{Squeeze}/\textsc{Ratchet} operations, which is IND-CCA2 secure.

The latter portion of \texttt{veil.mres} is an EdDSA-style Schnorr signature scheme.
The EdDSA-style Schnorr signature is sUF-CMA secure when implemented in a prime order group and a cryptographic hash
function~\cite{brendel2021, chalkias2020, pointcheval2000, neven2009} (see also~\ref{sec:veil.schnorr}).

\subsection{Multi-User Confidentiality}\label{subsec:veil.mres-conf}

One of the two main goals of the \texttt{veil.mres} is confidentiality in the multi-user setting
(see~\ref{subsec:sec-conf}), or the inability of an adversary $\Adversary$ to learn information about plaintexts.
As \texttt{veil.mres} is a multi-recipient scheme, we adopt Bellare et al.'s adaptation of the multi-user
setting, in which $\Adversary$ may compromise a subset of receivers~\cite{bellare2007}.

\subsubsection{Outsider Confidentiality}

First, we evaluate the confidentiality of \texttt{veil.mres} in the multi-user outsider setting
(see~\ref{subsubsec:sec-conf-outsider}), in which the adversary $\Adversary$ knows the public keys of all users but none
of their private keys~\cite[p. 44]{baek2010}.

As with \texttt{veil.sres} (see~\ref{subsec:veil.sres-conf}), \texttt{veil.mres} superficially resembles an
Encrypt-Then-Sign ($\EtS$) scheme, which are vulnerable to an attack where by $\Adversary$ strips the signature from the
challenge ciphertext and either signs it themselves or tricks the sender into signing it, thereby creating a new
ciphertext they can then trick the receiver into decrypting for them.
Again, as with \texttt{veil.sres}, the identity of the sender is strongly bound during encryption
encryption (see Alg.~\ref{alg:veil.mres-encrypt}, Line~\ref{alg:veil.mres-encrypt-bind-sender}) and decryption
(see Alg.~\ref{alg:veil.mres-decrypt}, Line~\ref{alg:veil.mres-decrypt-bind-sender}), making this infeasible.

$\Adversary$ is unable to forge valid signatures for existing ciphertexts, limiting them to passive attacks.
\texttt{veil.mres} ciphertexts consist of ephemeral keys, encrypted headers, random padding, encrypted message blocks,
and encrypted signature points.
Each component of the ciphertext is dependent on the previous inputs (including the headers, which use
\textsc{Squeeze}-derived nonce to link the \texttt{veil.sres} ciphertexts to the \texttt{veil.mres} state).
A passive attack on any of those would only be possible if Xoodyak is not IND-CPA secure.

\subsubsection{Insider Confidentiality}

Next, we evaluate the confidentiality of \texttt{veil.mres} in the multi-user insider setting
(see~\ref{subsubsec:sec-conf-insider}), in which the adversary $\Adversary$ knows the sender's private key in addition
to the public keys of all users~\cite[p. 45--46]{baek2010}.

$\Adversary$ cannot decrypt the message by themselves, as they do not know either $d_E$ or any $d_R$ and cannot decrypt
any of the \texttt{veil.sres}-encrypted headers.

As with \texttt{veil.sres} (see~\ref{subsec:veil.sres-conf}),
$\Adversary$ cannot trick the receiver into decrypting an equivalent message by replacing the signature, despite
$\Adversary$'s ability to use $d_S$ to create new headers.
In order to generate a valid signature on a ciphertext $c'$ (e.g.\ $c'=c||1$), $\Adversary$ would have to squeeze a
valid challenge scalar $r'$ from the duplex state (see Alg.~\ref{alg:veil.mres-encrypt},
line~\ref{alg:veil.mres-encrypt-challenge}).
Unlike the signature hash function in the generic $\EtS$ composition, however, the duplex state is cryptographically
dependent on a value $\Adversary$ does not know, specifically the data encryption key $K$ (via the \textsc{Cyclist}
operation) and the plaintext blocks $p_{0..n}$ (via the \textsc{Encrypt} operation).

Therefore, \texttt{veil.mres} provides confidentiality in the multi-user insider setting.

\subsection{Multi-User Authenticity}\label{subsec:veil.mres-auth}

The second of the two main goals of the \texttt{veil.mres} is authenticity in the multi-user setting
(see~\ref{subsec:sec-auth}), or the inability of an adversary $\Adversary$ to forge valid ciphertexts.

\subsubsection{Outsider Authenticity}

First, we evaluate the authenticity of \texttt{veil.mres} in the multi-user outsider setting
(see~\ref{subsubsec:sec-auth-outsider}), in which the adversary $\Adversary$ knows the public keys of all users but none
of their private keys~\cite[p. 47]{baek2010}.

Because the Schnorr signature scheme is sUF-CMA secure, it is infeasible for $\Adversary$ to forge a signature for a new
message or modify an existing signature for an existing message.
Therefore, \texttt{veil.mres} provides authenticity in the multi-user outsider setting.

\subsubsection{Insider Authenticity}

Next, we evaluate the authenticity of \texttt{veil.mres} in the multi-user insider setting
(see~\ref{subsubsec:sec-auth-insider}), in which the adversary $\Adversary$ knows some receivers' private keys in
addition to the public keys of both users~\cite[p. 48]{baek2010}.

Again, the Schnorr signature scheme is sUF-CMA secure and the signature is created using the ephemeral private key,
which $\Adversary$ does not possess.
The receiver (or $\Adversary$ in possession of the receiver's private key) cannot forge signatures for new messages.
Therefore, \texttt{veil.mres} provides authenticity in the multi-user insider setting.

\subsection{Limited Deniability}\label{subsec:veil.mres-deniability}

The only portion of \texttt{veil.mres} ciphertexts which are creating using the sender's private key (and thus tying
a particular message to their identity) are the \texttt{veil.sres}-encrypted headers.
All other components are creating using the data encryption key or ephemeral private key, neither of which are bound
to identity.
\texttt{veil.sres} provides limited deniability (see~\ref{subsec:veil.sres-deniability}), therefore \texttt{veil.mres}
does as well.

\subsection{Indistinguishability From Random Noise}\label{subsec:veil.mres-indistinguishability}

\texttt{veil.mres} ciphertexts are indistinguishable from random noise.
The ephemeral public key is encoded using Elligator2, which maps points on an elliptic curve to uniform bitstrings.
All other components of an \texttt{veil.mres} ciphertext are Xoodyak ciphertexts;
a successful distinguishing attack on them would require Xoodyak to not be IND-CPA secure.

\subsubsection{Elligator2 And Ristretto}

To encode a Ristretto point $Q$, Veil iterates over the point's $\mathcal E[4]$ coset of Edwards points, converting each
to Montomgery points and mapping them via Elligator2 to bitstrings.
The first bitstring which can be decoded as the original Ristretto point $Q$ is returned, if any exist.
This is likely a suboptimal approach.

\subsection{Partial Decryption}\label{subsec:veil.mres-partial-decryption}

The division of the plaintext stream into blocks takes its inspiration from the CHAIN construction~\cite{hoang2015}, but
the use of Xoodyak allows for a significant reduction in complexity.
Instead of using the nonce and associated data to create a feed-forward ciphertext dependency, the Xoodyak duplex
ensures all encryption operations are cryptographically dependent on the ciphertext of all previous encryption
operations.
Likewise, because the \texttt{veil.mres} ciphertext is terminated with a Schnorr signature (see
Sec.~\ref{sec:veil.schnorr}), using a special operation for the final message block isn't required.

The major limitation of such a system is the possibility of the partial decryption of invalid ciphertexts.
If an attacker flips a bit on the fourth block of a ciphertext, \texttt{veil.mres} will successfully decrypt the first
three before returning an error.
If the end-user interface displays that, the attacker may be successful in radically altering the semantics of an
encrypted message without the user's awareness.
The first three blocks of a message, for example, could say \texttt{PAY MALLORY \$100}, \texttt{GIVE HER YOUR CAR},
\texttt{DO WHAT SHE SAYS}, while the last block might read \texttt{JUST KIDDING}.
