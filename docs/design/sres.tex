\section{Encrypted Headers}\label{sec:veil.sres}

\texttt{veil.sres} implements a single-receiver, deniable signcryption scheme which Veil uses to encrypt message
headers.
It integrates an ephemeral ECDH KEM, a Xoodyak DEM, and a designated-verifier Schnorr signature scheme to provide
multi-user insider security.

\subsection{Encrypting A Header}\label{subsec:veil.sres-encrypt}

Encrypting a header is described in full in Alg.~\ref{alg:veil.sres-encrypt}.

\begin{algorithm}[!htp]
    \caption{
        Encrypting a header with sender's key pair $(d_S, Q_S)$, ephemeral key pair $(d_E, Q_E)$, receiver's public key
        $Q_R$, nonce $N$, and plaintext $P$.
    }
    \begin{algorithmic}[1]
        \Function{EncryptHeader}{$(d_S, Q_S), (d_E, Q_E), Q_R, N, P$}
            \State \Call{Absorb}{\texttt{veil.sres}}\Comment{Initialize an unkeyed duplex.}

            \State \Call{Absorb}{$Q_S$}\label{alg:veil.sres-encrypt-bind-sender}\Comment{Absorb the sender's public key.}
            \State \Call{Absorb}{$Q_R$}\Comment{Absorb the receiver's public key.}
            \State \Call{Absorb}{$Q_E$}\Comment{Absorb the ephemeral public key.}
            \State \Call{Absorb}{$N$}\Comment{Absorb the nonce.}
            \State

            \State \Call{Absorb}{$d_S[Q_E]$, $\epsilon$, $\epsilon$}\Comment{Absorb the ECDH shared secret.}
            \State \Call{Cyclist}{\textsc{SqueezeKey}($32$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
            \State $C \gets$ \Call{Encrypt}{$P$}\Comment{Encrypt the plaintext.}

            \State
            \Clone \Comment{Clone the duplex's state.}
            \State \Call{Absorb}{$d_S$}\Comment{Absorb the sender's private key.}
            \State $v \rgets \allbits{512}$\Comment{Generate a random value.}
            \State \Call{Absorb}{$v$}\Comment{Absorb the random value.}
            \State $k \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze a commitment scalar.}
            \State \textbf{yield} $k$
            \End
            \State
            \State $I \gets [k]G$\Comment{Calculate the commitment point.}
            \State $S_0 \gets$ \Call{Encrypt}{$I$}\Comment{Encrypt the commitment point.}
            \State
            \State $r \gets$ \Call{Squeeze}{$64$} $\modl$
            \label{alg:veil.sres-encrypt-challenge}
            \Comment{Squeeze a challenge scalar.}
            \State $s \gets d_S{r}+k$\Comment{Calculate the proof scalar.}
            \State
            \State $X \gets [s]Q_R$\Comment{Calculate the proof point.}
            \State $S_1 \gets$ \Call{Encrypt}{$X$}\Comment{Encrypt the proof point.}
            \State
            \State \textbf{return} $C||S_0||S_1$
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.sres-encrypt}
\end{algorithm}

\subsection{Decrypting A Header}\label{subsec:veil.sres-decrypt}

Decrypting a header is described in full in Alg.~\ref{alg:veil.sres-decrypt}.

\begin{algorithm}[!htp]
    \caption{
        Decrypting a header with receiver's key pair $(d_R, Q_R)$, sender's public key $Q_S$, ephemeral public key
        $Q_E$, nonce $N$, and ciphertext $C||S_0||S_1$.
    }
    \begin{algorithmic}[1]
        \Function{DecryptHeader}{$(d_R, Q_R), Q_S, Q_E, N, C||S_0||S_1$}
            \State \Call{Absorb}{\texttt{veil.sres}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$Q_S$}\label{alg:veil.sres-decrypt-bind-sender}\Comment{Absorb the sender's public key.}
            \State \Call{Absorb}{$Q_R$}\Comment{Absorb the receiver's public key.}
            \State \Call{Absorb}{$Q_E$}\Comment{Absorb the ephemeral public key.}
            \State \Call{Absorb}{$N$}\Comment{Absorb the nonce.}
            \State
            \State \Call{Absorb}{$d_R[Q_E]$}\Comment{Absorb the ECDH shared secret.}
            \State \Call{Cyclist}{\textsc{SqueezeKey}($32$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
            \State $P' \gets$ \Call{Decrypt}{$C$}\Comment{Decrypt the plaintext.}
            \State
            \State $I \gets$ \Call{Decrypt}{$S_0$}\Comment{Decrypt the commitment point.}
            \State $r \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze a challenge scalar.}
            \State
            \State $X \gets$ \Call{Decrypt}{$S_1$}\Comment{Decrypt the proof point.}
            \State $X' \gets [d_R](I + [r]Q_S)$\Comment{Re-calculate the proof point.}
            \State
            \If{$X' \checkeq X$}\Comment{Ensure the ciphertext is authentic.}
                \State \textbf{return} $P'$
            \Else
                \State \textbf{return} $\bot$
            \EndIf
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.sres-decrypt}
\end{algorithm}

\subsection{Constructive Analysis Of \texttt{veil.sres}}\label{subsec:veil.sres-analysis}

\texttt{veil.sres} is an integration of two well-known constructions: an ECIES-style hybrid public key encryption scheme
and a designated-verifier Schnorr signature scheme.

The initial portion of \texttt{veil.sres} is equivalent to ECIES (see Construction 12.23 of~\cite[p. 435]{katz2020}),
(with the commitment point $I$ as an addition to the ciphertext, and the challenge scalar $r$ serving as the
authentication tag for the data encapsulation mechanism) and is IND-CCA2 secure (see Corollary 12.14
of~\cite[p. 436]{katz2020}).

The latter portion of \texttt{veil.sres} is a designated-verifier Schnorr signature scheme which adapts an EdDSA-style
Schnorr signature scheme by multiplying the proof scalar $s$ by the receiver's public key $Q_R$ to produce a
designated-verifier point $X$~\cite{steinfeld2004}.
The EdDSA-style Schnorr signature is sUF-CMA secure when implemented in a prime order
group and a cryptographic hash function~\cite{brendel2021, chalkias2020, pointcheval2000, neven2009}
(see also Sec.~\ref{sec:veil.schnorr}).

\subsection{Multi-User Confidentiality}\label{subsec:veil.sres-conf}

One of the two main goals of the \texttt{veil.sres} is confidentiality in the multi-user setting
(see Sec.~\ref{subsec:sec-conf}), or the inability of an adversary $\Adversary$ to learn information about plaintexts.

\subsubsection{Outsider Confidentiality}

First, we evaluate the confidentiality of \texttt{veil.sres} in the multi-user outsider setting
(see Sec.~\ref{subsubsec:sec-conf-outsider}), in which the adversary $\Adversary$ knows the public keys of all users but
none of their private keys~\cite[p. 44]{baek2010}.

The classic multi-user attack on the generic Encrypt-Then-Sign ($\EtS$) construction sees $\Adversary$ strip the
signature $\sigma$ from the challenge ciphertext
\[
    C=(c,\sigma,Q_S,Q_R)
\]
and replace it with
\[
    \sigma' \rgets \text{Sign}(d_{\Adversary},c)
\]
to produce an attacker ciphertext
\[
    C'=(c,\sigma',Q_{\Adversary},Q_R)
\]
at which point $\Adversary$ can trick the receiver into decrypting the result and giving $\Adversary$ to the
randomly-chosen plaintext $m_0 \lor m_1$~\cite[p. 40]{an2010}.
This attack is not possible with \texttt{veil.sres}, as the sender's public key is strongly bound during
encryption (see Alg.~\ref{alg:veil.sres-encrypt}, Line~\ref{alg:veil.sres-encrypt-bind-sender}) and decryption
(see Alg.~\ref{alg:veil.sres-decrypt}, Line~\ref{alg:veil.sres-decrypt-bind-sender}).

$\Adversary$ is unable to forge valid signatures for existing ciphertexts, limiting them to passive attacks.
A passive attack on any of the three components of \texttt{veil.sres} ciphertexts--$C$, $S_0$, $S_1$--would only be
possible if Xoodyak is not IND-CPA secure.

Therefore, \texttt{veil.sres} provides confidentiality in the multi-user outsider setting.

\subsubsection{Insider Confidentiality}

Next, we evaluate the confidentiality of \texttt{veil.sres} in the multi-user insider setting
(see Sec.~\ref{subsubsec:sec-conf-insider}), in which the adversary $\Adversary$ knows the sender's private key in
addition to the public keys of both users~\cite[p. 45--46]{baek2010}.

$\Adversary$ cannot decrypt the message by themselves, as they do not know either $d_E$ or $d_R$ and cannot calculate
the ECDH shared secret $[d_E]Q_R=[d_R]Q_E=[d_E{d_R}G]$.

$\Adversary$ also cannot trick the receiver into decrypting an equivalent message by replacing the signature, despite
$\Adversary$'s ability to use $d_S$ to create new signatures.
In order to generate a valid signature on a ciphertext $c'$ (e.g.\ $c'=c||1$), $\Adversary$ would have to squeeze a
valid challenge scalar $r'$ from the duplex state (see Alg.~\ref{alg:veil.sres-encrypt},
Line~\ref{alg:veil.sres-encrypt-challenge}).
Unlike the signature hash function in the generic $\EtS$ composition, however, the duplex state is cryptographically
dependent on values $\Adversary$ does not know, specifically the ECDH shared secret $[d_E]Q_S$ (via the \textsc{Absorb}
operation) and the plaintext $P$ (via the \textsc{Encrypt} operation).

Therefore, \texttt{veil.sres} provides confidentiality in the multi-user insider setting.

\subsection{Multi-User Authenticity}\label{subsec:veil.sres-auth}

The second of the two main goals of the \texttt{veil.sres} is authenticity in the multi-user setting
(see Sec.~\ref{subsec:sec-auth}), or the inability of an adversary $\Adversary$ to forge valid ciphertexts.

\subsubsection{Outsider Authenticity}

First, we evaluate the authenticity of \texttt{veil.sres} in the multi-user outsider setting
(see Sec.~\ref{subsubsec:sec-auth-outsider}), in which the adversary $\Adversary$ knows the public keys of all users but
none of their private keys~\cite[p. 47]{baek2010}.

Because the Schnorr signature scheme is sUF-CMA secure, it is infeasible for $\Adversary$ to forge a signature for a new
message or modify an existing signature for an existing message.
Therefore, \texttt{veil.sres} provides authenticity in the multi-user outsider setting.

\subsubsection{Insider Authenticity}

Next, we evaluate the authenticity of \texttt{veil.sres} in the multi-user insider setting
(see Sec.~\ref{subsubsec:sec-auth-insider}), in which the adversary $\Adversary$ knows the receiver's private key in
addition to the public keys of both users~\cite[p. 48]{baek2010}.

Again, the Schnorr signature scheme is sUF-CMA secure and the signature is created using the signer's private key.
The receiver (or $\Adversary$ in possession of the receiver's private key) cannot forge signatures for new messages.
Therefore, \texttt{veil.sres} provides authenticity in the multi-user insider setting.

\subsection{Limited Deniability}\label{subsec:veil.sres-deniability}

\texttt{veil.sres}'s use of a designated-verifier Schnorr scheme provides limited deniability for senders
(see Sec.~\ref{subsec:security-deniability}).
Without revealing $d_R$, the receiver cannot prove the authenticity of a message (including the identity of its sender)
to a third party.

\subsection{Indistinguishability From Random Noise}\label{subsec:veil.sres-indistinguishability}

All of the components of a \texttt{veil.sres} ciphertext--$C$, $S_0$, and $S_1$--are Xoodyak ciphertexts.
An adversary in the outsider setting (i.e.\ knowing only public keys) is unable to calculate any of the key material
used to produce the ciphertexts;
a distinguishing attack is infeasible if Xoodyak is IND-CPA secure.

\subsection{Re-use Of Ephemeral Keys}\label{subsec:veil.sres-re-using-ephemeral-keys}

The re-use of an ephemeral key pair $(d_E, Q_E)$ across multiple ciphertexts does not impair the confidentiality of the
scheme provided $(N, Q_R)$ pairs are not re-used~\cite{bellare2003}.
An adversary who compromises a retained ephemeral private key would be able to decrypt all messages the sender encrypted
using that ephemeral key, thus the forward sender security is bounded by the sender's retention of the ephemeral private
key.
