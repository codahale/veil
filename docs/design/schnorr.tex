\section{Digital Signatures}\label{sec:veil.schnorr}

\texttt{veil.schnorr} implements a qDSA-style~\cite{renes2017} Schnorr digital signature scheme on the Montgomery curve
of Curve25519~\cite{bernstein2006}.

\subsection{Signing A Message}\label{subsec:veil.schnorr-sign}

Signing a message is described in full in Alg.~\ref{alg:veil.schnorr-sign}.

\begin{algorithm}[!htp]
    \caption{
        Signing a message $M$ with a key pair $(d, Q)$.
    }
    \begin{algorithmic}
        \Function{Sign}{$(d_S, Q_S), M$}
            \State \Call{Absorb}{\texttt{veil.schnorr}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$Q$}\Comment{Absorb the signer's public key.}
            \State \Call{Absorb}{$M$}\Comment{Absorb the message.}
            \State
            \Clone \Comment{Clone the duplex's state.}
            \State \Call{Absorb}{$d$}\Comment{Absorb the sender's private key.}
            \State $v \rgets \allbits{512}$\Comment{Generate a random value.}
            \State \Call{Absorb}{$v$}\Comment{Absorb the random value.}
            \State $k \gets$ \Call{Squeeze}{$64$} $\modl$
            \State \textbf{yield} $k$\Comment{Yield a hedged commitment scalar.}
            \End
            \State
            \State \Call{Cyclist}{\textsc{SqueezeKey}($64$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
            \State
            \State $I \gets [k]G$\Comment{Calculate the commitment point.}
            \State $S_0 \gets $ \Call{Encrypt}{$I$}\Comment{Encrypt the commitment point.}
            \State
            \State $\bar{r} \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze a challenge scalar with a zero LSB.}
            \State $\bar{s} \gets |d\bar{r} + k|$\Comment{Calculate the proof scalar with a zero LSB.}
            \State $S_1 \gets $ \Call{Encrypt}{$\bar{s}$}\Comment{Encrypt the proof scalar.}
            \State
            \State \textbf{return} $S=S_0 || S_1$
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.schnorr-sign}
\end{algorithm}

\subsection{Verifying A Signature}\label{subsec:veil.schnorr-verify}

Verifying a signature is described in full in Alg.~\ref{alg:veil.schnorr-verify}.

\begin{algorithm}[!htp]
    \caption{
        Verifying a signature $S$ with a message $M$ and a public key $Q$.
    }
    \begin{algorithmic}
        \Function{Verify}{$Q, M, S=S_0||S_1$}
            \State \Call{Absorb}{\texttt{veil.schnorr}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$Q$}\Comment{Absorb the signer's public key.}
            \State \Call{Absorb}{$M$}\Comment{Absorb the message.}
            \State
            \State \Call{Cyclist}{\textsc{SqueezeKey}($64$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
            \State
            \State $I \gets $ \Call{Decrypt}{$S_0$}\Comment{Decrypt the commitment point.}
            \State $\bar{r} \gets$ \Call{Squeeze}{$64$} $\modl$\Comment{Squeeze a challenge scalar with a zero LSB.}
            \State $s \gets $ \Call{Decrypt}{$S_1$}\Comment{Decrypt the proof scalar.}
            \If{$s \neq \bar{s}$}\Comment{The LSB of $s$ must be zero.}
                \State \textbf{return} $\bot$
            \EndIf
            \State
            \State \textbf{return} $\pm I \checkeq \pm ([\bar{s}]G \pm [\bar{r}]Q_S)$\Comment{Check equality up to sign.}
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.schnorr-verify}
\end{algorithm}

\subsection{Constructive Analysis Of \texttt{veil.schnorr}}\label{subsec:veil.schnorr-analysis}

The Schnorr signature scheme is the application of the Fiat-Shamir transform to the Schnorr identification scheme using
qDSA~\cite{renes2017}'s adaptation to Kummer varieties.

\subsection{UF-CMA Security}\label{subsec:veil.schnorr-uf-cma}

Per Renes~\cite{renes2017}, this construction is UF-CMA secure.

\subsection{sUF-CMA Security}\label{subsec:veil.schnorr-suf-cma}

When implemented with a prime order group and canonical encoding routines, the Schnorr signature scheme is strongly
unforgeable under chosen message attack (sUF-CMA) in the random oracle model~\cite{pointcheval2000} and even with
practical cryptographic hash functions~\cite{neven2009}.

The qDSA scheme as described, however, permits both $(I, s)$ and $(I, -s)$ as valid signatures of a single message.
Veil restricts valid signatures to those in which $s$ has a least significant bit of zero, making it sUF-CMA secure.

\subsection{Key Privacy}\label{subsec:veil.schnorr-key-privacy}

EdDSA-type signatures (i.e.\ $S=(I,s)$) allow for the recovery of the signing public key given a signature and a
message: given the commitment point $I$, one can calculate $Q=-[r^{-1}](I - [s]G)$.

For Veil, this behavior is not desirable.
A global passive adversary should not be able to discover the identity of a signer from a signed message.

To eliminate this possibility, \texttt{veil.schnorr} encrypts both components of the signature with a duplex keyed with
the signer's public key in addition to the message.
An attack which recovers the plaintext of either signature component in the absence of the public key would imply that
Cyclist is not IND-CPA\@.

\subsection{Indistinguishability From Random Noise}\label{subsec:veil.schnorr-indistinguishability}

Given that both signature components are encrypted with Cyclist, an attack which distinguishes between a
\texttt{veil.schnorr} and random noise would also imply that Cyclist is not IND-CPA\@.
