\section{Passphrase-Based Encryption}\label{sec:veil.pbenc}

\texttt{veil.pbenc} implements a memory-hard authenticated encryption scheme to encrypt private keys at rest.

\subsection{Initialization}\label{subsec:veil.pbenc-init}

Initializing a duplex from a passphrase is described in full in Alg.~\ref{alg:veil.pbenc-hash} and
Alg.~\ref{alg:veil.pbenc-init}\@.

\begin{algorithm}
    \caption{
        Producing a hashed block given a counter $C$, a sequence of input blocks $B_0..B_n$, and an output length $N$.
    }
    \begin{algorithmic}
        \Function{Hash}{$C, B_0..B_n, N$}
            \State \Call{Absorb}{\texttt{veil.pbenc.iter}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$c$}\Comment{Absorb the counter.}
            \State $C \gets C + 1$\Comment{Increment the counter.}
            \ForAll{$B_i \in \{B_0..B_n\}$}
                \State \Call{Absorb}{$B_i$}\Comment{Absorb each piece of data.}
            \EndFor
            \State \textbf{return} \Call{Squeeze}{$N$}\Comment{Squeeze $N$ bytes of output.}
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-hash}
\end{algorithm}

\begin{algorithm}
    \caption{
        Initializing a duplex given a passphrase $P$, salt $S$, time parameter $N_T$, space parameter $N_S$, delta
        constant $D = 3$, and block size constant $N_B = 32$.
    }
    \begin{algorithmic}
        \Procedure{InitFromPassphrase}{$P, S, N_T, N_S$}
            \State $C \gets 0$\Comment{Initialize a counter.}
            \State $B \gets [[\texttt{0x00} \times N_B] \times N]$\Comment{Initialize an array of $N$ blocks.}
            \Statex
            \State $B[0] \gets $\Call{Hash}{$C, P, S, N_B$}\Comment{Expand input into buffer.}
            \For{$m \in 1..N_S$}
                \State $B[m] \gets $\Call{Hash}{$C, B[m-1], N_B$}\Comment{Fill remainder of buffer with hash chain.}
            \EndFor
            \Statex
            \For{$t \in 0..N_T$}\Comment{Mix buffer contents.}
                \For{$m \in 0..N_S$}
                    \State $m_{prev} \gets m-1 \bmod N_S$
                    \State $B[m] \gets $\Call{Hash}{$C, B[m_{prev}], B[m], N_B$}\Comment{Hash previous and current blocks.}
                    \For{$i \in 0..D$}
                        \State $r \gets $\Call{Hash}{$C, S, t, m, i, 8$}$ \bmod N_S$\Comment{Hash loop indexes.}
                        \State $B[m] \gets $\Call{Hash}{$C, B[m], B[r], N_B$}\Comment{Hash random and current blocks.}
                    \EndFor
                \EndFor
            \EndFor
            \Statex
            \State \Call{Absorb}{\texttt{veil.pbenc}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$B[N_S-1]$}\Comment{Extract output from buffer.}
            \State \Call{Cyclist}{\textsc{SqueezeKey}($64$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
        \EndProcedure
    \end{algorithmic}
    \label{alg:veil.pbenc-init}
\end{algorithm}

\subsection{Encrypting A Private Key}\label{subsec:veil.pbenc-encrypt}

Encrypting a private key is described in full in Alg.~\ref{alg:veil.pbenc-encrypt}\@.

\begin{algorithm}
    \caption{
        Encrypting a private key given a passphrase $P$, time parameter $N_T$, space parameter $N_S$, and
        private key $d$.
    }
    \begin{algorithmic}
        \Function{EncryptPrivateKey}{$P, N_T, N_S, d$}
            \State $S \rgets \allbits{128}$\Comment{Generate a random salt.}
            \State \Call{InitFromPassphrase}{$P, S, N_T, N_S$}\Comment{Initialize the duplex.}
            \State $C \gets$\Call{Encrypt}{$d$}\Comment{Encrypt the private key.}
            \State $T \gets$\Call{Squeeze}{$16$}\Comment{Squeeze an authentication tag.}
            \State \textbf{return} $N_T || N_S || S || C ||T$
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-encrypt}
\end{algorithm}

\subsection{Decrypting A Private key}\label{subsec:veil.pbenc-decrypt}

Decrypting a private key is described in full in Alg.~\ref{alg:veil.pbenc-decrypt}\@.

\begin{algorithm}
    \caption{
        Decrypt a private key given a passphrase $P$ and ciphertext $C$.
    }
    \begin{algorithmic}
        \Function{DecryptPrivateKey}{$P, C=N_T || N_S || S || C ||T$}
            \State \Call{InitFromPassphrase}{$P, S, N_T, N_S$}\Comment{Initialize the duplex.}
            \State $d' \gets$\Call{Decrypt}{$C$}\Comment{Decrypt the ciphertext.}
            \State $T' \gets$\Call{Squeeze}{$16$}\Comment{Squeeze a counterfactual tag.}
            \If{$T' \checkeq T$}
                \Comment{Authenticate the ciphertext.}
                \State \textbf{return} $d'$
            \Else
                \State \textbf{return} $\bot$
            \EndIf
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-decrypt}
\end{algorithm}

\subsection{Constructive Analysis Of \texttt{veil.pbenc}}\label{subsec:veil.pbenc-analysis}

\texttt{veil.pbenc} is an integration of a memory-hard key derivation function \@(adapted for the cryptographic duplex)
and a standard Cyclist authenticated encryption scheme.

The \textsc{InitFromPassphrase} procedure of \texttt{veil.pbenc} implements balloon hashing, a memory-hard KDF intended
for hashing low-entropy passphrases~\cite{boneh2016}.
Memory-hard functions are a new and active area of cryptographic research, making the evaluation of schemes difficult.
Balloon hashing was selected for its resilience to timing attacks, its reliance on a single hash primitive, and its
relatively well-developed security proofs.

The \textsc{EncryptPrivateKey} and \textsc{DecryptPrivateKey} functions use \textsc{InitFromPassphrase} to initialize
the duplex state, after which they implement a standard Cyclist authenticated encryption scheme, which is IND-CCA2
secure.
