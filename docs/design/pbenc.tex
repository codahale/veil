\section{Passphrase-Based Encryption}\label{sec:veil.pbenc}

\texttt{veil.pbenc} implements a memory-hard authenticated encryption scheme to encrypt private keys at rest.

\subsection{Initialization}\label{subsec:veil.pbenc-init}

Initializing a duplex from a passphrase is described in full in Alg.~\ref{alg:veil.pbenc-init}\@.

\begin{algorithm}[ht]
    \caption{
        Initializing a duplex given a passphrase $P$, salt $S$, time parameter $N_T$, space parameter $N_S$, delta
        constant $D = 3$, and block size constant $N_B = 1024$.
    }
    \begin{algorithmic}
        \Function{Hash}{$B_0..B_n, N$}
            \State $c \gets c + 1$
            \State \Call{Absorb}{\texttt{veil.pbenc.iter}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$c$}
            \ForAll{$B_i \in \{B_0..B_n\}$}
                \State \Call{Absorb}{$B_i$}
            \EndFor
            \State \textbf{return} \Call{Squeeze}{$N$}
        \EndFunction
        \Procedure{InitFromPassphrase}{$P, S, N_T, N_S$}
            \State $P_N \gets$\Call{NormalizeNFC}{$P$}\Comment{Normalize the passphrase.}
            \State
            \State $c \gets 0$\Comment{Initialize a counter.}
            \State $B \gets [[\texttt{0x00} \times N_B] \times N]$\Comment{Initialize an array of $N$ blocks.}
            \State $B[0] \gets $\Call{Hash}{$P_N, S, N_B$}\Comment{Expand input into buffer.}
            \For{$m$ in $1..N_S$}
                \State $B[m] \gets $\Call{Hash}{$B[m-1], N_B$}
            \EndFor
            \State
            \For{$t$ in $0..N_T$}
                \Comment{Mix buffer contents.}
                \For{$m$ in $0..N_S$}\Comment{Hash last and current blocks.}
                    \State $B[m] \gets $\Call{Hash}{$B[m-1 \bmod N_S], B[m], N_B$}
                    \For{$i$ in $0..D$}\Comment{Hash in pseudo-randomly chosen blocks.}
                        \State $I \gets $\Call{Hash}{$S, t, m, i, 8$}$ \bmod N_S$
                        \State $B[m] \gets $\Call{Hash}{$B[m], B[I], N_B$}
                    \EndFor
                \EndFor
            \EndFor
            \State
            \State \Call{Absorb}{\texttt{veil.pbenc}}\Comment{Initialize an unkeyed duplex.}
            \State \Call{Absorb}{$B[N_S-1]$}\Comment{Extract output from buffer.}
            \State \Call{Cyclist}{\textsc{SqueezeKey}($64$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
        \EndProcedure
    \end{algorithmic}
    \label{alg:veil.pbenc-init}
\end{algorithm}

\subsection{Encrypting A Private Key}\label{subsec:veil.pbenc-encrypt}

Encrypting a private key is described in full in Alg.~\ref{alg:veil.pbenc-encrypt}\@.

\begin{algorithm}[ht]
    \caption{
        Encrypting a private key given a passphrase $P$, time parameter $N_T$, space parameter $N_S$, and
        private key $d$.
    }
    \begin{algorithmic}
        \Function{EncryptPrivateKey}{$P, N_T, N_S, d$}
            \State $S \rgets \allbits{128}$\Comment{Generate a random salt.}
            \State \Call{InitFromPassphrase}{$P, S, N_T, N_S$}\Comment{Initialize the duplex.}
            \State $C \gets$\Call{Encrypt}{$d$}\Comment{Encrypt the private key.}
            \State $T \gets$\Call{Squeeze}{$16$}\Comment{Squeeze an authentication tag.}
            \State \textbf{return} $N_T || N_S || S || C ||T$
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-encrypt}
\end{algorithm}

\subsection{Decrypting A Private key}\label{subsec:veil.pbenc-decrypt}

Decrypting a private key is described in full in Alg.~\ref{alg:veil.pbenc-decrypt}\@.

\begin{algorithm}[ht]
    \caption{
        Decrypt a private key given a passphrase $P$ and ciphertext $C$.
    }
    \begin{algorithmic}
        \Function{DecryptPrivateKey}{$P, C=N_T || N_S || S || C ||T$}
            \State \Call{InitFromPassphrase}{$P, S, N_T, N_S$}\Comment{Initialize the duplex.}
            \State $d' \gets$\Call{Decrypt}{$C$}\Comment{Decrypt the ciphertext.}
            \State $T' \gets$\Call{Squeeze}{$16$}\Comment{Squeeze a counterfactual tag.}
            \If{$T' \checkeq T$}\Comment{Authenticate the ciphertext.}
            \State \textbf{return} $d'$
            \Else
                \State \textbf{return} $\bot$
            \EndIf
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-decrypt}
\end{algorithm}

\subsection{Constructive Analysis Of \texttt{veil.pbenc}}\label{subsec:veil.pbenc-analysis}

\texttt{veil.pbenc} is an integration of a memory-hard key derivation function \@(adapted for the cryptographic duplex)
and a standard Cyclist authenticated encryption scheme.

The \textsc{InitFromPassphrase} procedure of \texttt{veil.pbenc} implements balloon hashing, a memory-hard KDF intended
for hashing low-entropy passphrases~\cite{boneh2016}.
Memory-hard functions are a new and active area of cryptographic research, making the evaluation of schemes difficult.
Balloon hashing was selected for its resilience to timing attacks, its reliance on a single hash primitive, and its
relatively well-developed security proofs.

The \textsc{EncryptPrivateKey} and \textsc{DecryptPrivateKey} functions use \textsc{InitFromPassphrase} to initialize
the duplex state, after which they implement a standard Cyclist authenticated encryption scheme, which is IND-CCA2
secure.
