\section{Passphrase-Based Encryption}\label{sec:veil.pbenc}

\texttt{veil.pbenc} implements a memory-hard authenticated encryption scheme to encrypt private keys
at rest.

\subsection{Encrypting A Private Key}\label{subsec:veil.pbenc-encrypt}

Encrypting a private key is described in full in Alg.~\ref{alg:veil.pbenc-encrypt}\@.

\begin{algorithm}
    \caption{Encrypting a private key $d$ given a passphrase $P$, memory cost parameter $C_M$, time
        cost parameter $C_T$, and parallelism cost parameter $C_P$.}
    \begin{algorithmic}
        \Function{EncryptPrivateKey}{$P, M_{cost}, T_{cost}, d$}
        \State \Call{Absorb}{\texttt{veil.pbenc}}\Comment{Initialize an unkeyed duplex.}
        \State $P_N \gets$\Call{NormalizeNFC}{$P$}\Comment{Normalize the passphrase.}
        \State $S \rgets \allbits{128}$\Comment{Generate a random salt.}
        \State $K \gets $\Call{Argon2id}{\texttt{0x13}, $P_N, S, C_M, C_T, C_P, 64$}\Comment{Hash the passphrase.}
        \State \Call{Absorb}{$K$}\Comment{Absorb the derived key.}
        \State \Call{Cyclist}{\textsc{SqueezeKey}($64$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
        \State $C \gets$\Call{Encrypt}{$d$}\Comment{Encrypt the private key.}
        \State $T \gets$\Call{Squeeze}{$16$}\Comment{Squeeze an authentication tag.}
        \State \textbf{return} $C_M || C_T || C_P || S || C || T$
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-encrypt}
\end{algorithm}

\subsection{Decrypting A Private key}\label{subsec:veil.pbenc-decrypt}

Decrypting a private key is described in full in Alg.~\ref{alg:veil.pbenc-decrypt}\@.

\begin{algorithm}
    \caption{Decrypting a private key given a passphrase $P$ and ciphertext $C$.}
    \begin{algorithmic}
        \Function{DecryptPrivateKey}{$P, C=C_M || C_T || C_P || S || C || T$}
        \State \Call{Absorb}{\texttt{veil.pbenc}}\Comment{Initialize an unkeyed duplex.}
        \State $P_N \gets$\Call{NormalizeNFC}{$P$}\Comment{Normalize the passphrase.}
        \State $S \rgets \allbits{128}$\Comment{Generate a random salt.}
        \State $K \gets $\Call{Argon2id}{\texttt{0x13}, $P_N, S, C_M, C_T, C_P, 64$}\Comment{Hash the passphrase.}
        \State \Call{Absorb}{$K$}\Comment{Absorb the derived key.}
        \State \Call{Cyclist}{\textsc{SqueezeKey}($64$), $\epsilon$, $\epsilon$}\Comment{Convert to a keyed duplex.}
        \State $d' \gets$\Call{Decrypt}{$C$}\Comment{Decrypt the ciphertext.}
        \State $T' \gets$\Call{Squeeze}{$16$}\Comment{Squeeze a counterfactual tag.}
        \If{$T' \checkeq T$}\Comment{Authenticate the ciphertext.}
        \State \textbf{return} $d'$
        \Else
        \State \textbf{return} $\bot$
        \EndIf
        \EndFunction
    \end{algorithmic}
    \label{alg:veil.pbenc-decrypt}
\end{algorithm}

\subsection{Constructive Analysis Of \texttt{veil.pbenc}}\label{subsec:veil.pbenc-analysis}

\texttt{veil.pbenc} integrates Argon2~\cite{rfc9106}, a memory-hard key derivation function, and a
standard Cyclist authenticated encryption scheme. Argon2 increases the cost for an attacker to mount
a brute-force or dictionary attack using highly parallel hardware \@(e.g.\ GPUs, ASICs) by
increasing the per-core memory requirements for attempts.
