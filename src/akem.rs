//! An authenticated key encapsulation mechanism, per [Dent][dent].
//!
//! [dent]: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.3387&rep=rep1&type=pdf

use curve25519_dalek::constants::RISTRETTO_BASEPOINT_TABLE as G;
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::scalar::Scalar;
use secrecy::{ExposeSecret, Secret};

use crate::strobe::Protocol;

/// The length of the shared secret generated by [encapsulate] and [decapsulate].
pub const KEY_LEN: usize = 32;

/// Given the sender's key pair, the recipient's public key, and a message, returns a shared secret
/// and a pair of signature scalars.
#[must_use]
pub fn encapsulate(
    d_s: &Scalar,
    q_s: &RistrettoPoint,
    q_r: &RistrettoPoint,
    plaintext: &[u8],
) -> (Secret<[u8; KEY_LEN]>, (Scalar, Scalar)) {
    // Initialize the protocol.
    let mut akem = Protocol::new("veil.akem");

    // Include the sender and receiver as associated data.
    akem.send("sender-public-key", q_s.compress().as_bytes());

    // Receive the receiver's public key as cleartext.
    akem.receive("receiver-public-key", q_r.compress().as_bytes());

    // Generate a secret commitment scalar.
    let t = akem.hedge(d_s.as_bytes(), |clone| {
        // Also hedge with the plaintext message to ensure (d_s, plaintext, t) uniqueness.
        clone.key("plaintext", plaintext);
        clone.prf_scalar("commitment-scalar")
    });

    // Calculate the commitment point and add it as associated data.
    let x = q_r * t.expose_secret();
    akem.ad("commitment-point", x.compress().as_bytes());

    // Extract the shared secret.
    let k = Secret::new(akem.prf::<KEY_LEN>("shared-secret"));

    // Add the plaintext message as associated data.
    akem.ad("plaintext", plaintext);

    // Extract a challenge scalar from PRF output.
    let r = akem.prf_scalar("challenge-scalar");

    // Calculate the proof scalar.
    let s = t.expose_secret() * (r + d_s).invert();

    // Return the shared secret and thw two signature scalars.
    (k, (r, s))
}

/// Given the recipient's key pair, the sender's public key, and the two scalars returned by
/// [encapsulate], return the same shared secret as returned by [encapsulate] plus a [Protocol]
/// instance for use with [verify] once the plaintext message has been decrypted.
#[must_use]
pub fn decapsulate(
    d_r: &Scalar,
    q_r: &RistrettoPoint,
    q_s: &RistrettoPoint,
    r: &Scalar,
    s: &Scalar,
) -> (Secret<[u8; KEY_LEN]>, Protocol) {
    // Initialize the protocol.
    let mut akem = Protocol::new("veil.akem");

    // Include the sender and receiver as associated data.
    akem.receive("sender-public-key", q_s.compress().as_bytes());

    // Receive the receiver's public key as cleartext.
    akem.send("receiver-public-key", q_r.compress().as_bytes());

    // Calculate the commitment point and add it as associated data.
    let x = (q_s + (&G * r)) * (d_r * s);
    akem.ad("commitment-point", x.compress().as_bytes());

    // Extract the shared secret.
    let k = Secret::new(akem.prf::<KEY_LEN>("shared-secret"));

    // Return the shared secret and the protocol in its current state.
    (k, akem)
}

/// Given a [Protocol] returned by [decapsulate] and a decrypted plaintext, verify the signature.
/// No plaintext can be considered authentic without calling [verify].
pub fn verify(mut akem: Protocol, r: &Scalar, plaintext: &[u8]) -> bool {
    // Add the plaintext message as associated data.
    akem.ad("plaintext", plaintext);

    // Extract a challenge scalar from PRF output.
    let r_p = akem.prf_scalar("challenge-scalar");

    // Return true iff r' == r.
    r == &r_p
}

#[cfg(test)]
mod tests {
    use crate::sres::tests::setup;

    use super::*;

    #[test]
    fn round_trip() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);
        let (k2, akem) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_eq!(k1.expose_secret(), k2.expose_secret());
        assert!(verify(akem, &r, plaintext));
    }

    #[test]
    fn wrong_recipient_private_key() {
        let (d_s, q_s, _, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let d_r = Scalar::random(&mut rand::thread_rng());

        let (k2, _) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_ne!(k1.expose_secret(), k2.expose_secret());
    }

    #[test]
    fn wrong_recipient_public_key() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let q_r = RistrettoPoint::random(&mut rand::thread_rng());

        let (k2, _) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_ne!(k1.expose_secret(), k2.expose_secret());
    }

    #[test]
    fn wrong_sender_public_key() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let q_s = RistrettoPoint::random(&mut rand::thread_rng());

        let (k2, _) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_ne!(k1.expose_secret(), k2.expose_secret());
    }

    #[test]
    fn wrong_challenge_scalar() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (_, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let r = Scalar::random(&mut rand::thread_rng());
        let (k2, _) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_ne!(k1.expose_secret(), k2.expose_secret());
    }

    #[test]
    fn wrong_proof_scalar() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, _)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let s = Scalar::random(&mut rand::thread_rng());
        let (k2, _) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_ne!(k1.expose_secret(), k2.expose_secret());
    }

    #[test]
    fn wrong_plaintext() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);
        let (k2, akem) = decapsulate(&d_r, &q_r, &q_s, &r, &s);
        assert_eq!(k1.expose_secret(), k2.expose_secret());
        assert!(!verify(akem, &r, b"oh no"));
    }
}
