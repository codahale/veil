//! An authenticated key encapsulation mechanism, per [Dent][dent].
//!
//! [dent]: http://www.cogentcryptography.com/papers/inner.pdf

use curve25519_dalek::constants::RISTRETTO_BASEPOINT_TABLE as G;
use curve25519_dalek::ristretto::RistrettoPoint;
use curve25519_dalek::scalar::Scalar;
use secrecy::{ExposeSecret, Secret, SecretVec};

use crate::strobe::Protocol;

/// The length of the shared secret generated by [encapsulate] and [decapsulate].
pub const KEY_LEN: usize = 32;

/// Given the sender's key pair, the recipient's public key, and a message, returns a shared secret
/// and a pair of signature scalars.
#[must_use]
pub fn encapsulate(
    d_s: &Scalar,
    q_s: &RistrettoPoint,
    q_r: &RistrettoPoint,
    plaintext: &[u8],
) -> (SecretVec<u8>, (Scalar, Scalar)) {
    loop {
        // Initialize the protocol.
        let mut akem = Protocol::new("veil.akem");

        // Send the sender's public key as cleartext.
        akem.send("sender-public-key", q_s.compress().as_bytes());

        // Receive the receiver's public key as cleartext.
        akem.receive("receiver-public-key", q_r.compress().as_bytes());

        // Generate a secret commitment scalar.
        let t = akem.hedge(d_s.as_bytes(), |clone| {
            // Also hedge with the plaintext message to ensure (d_s, plaintext, t) uniqueness.
            clone.key("plaintext", plaintext);
            clone.prf_scalar("commitment-scalar")
        });

        // Calculate the commitment point and add it as associated data.
        let x = q_r * t.expose_secret();
        akem.ad("commitment-point", x.compress().as_bytes());

        // Extract the shared secret.
        let k = Secret::new(akem.prf_vec("shared-secret", KEY_LEN));

        // Add the plaintext message as associated data.
        akem.ad("plaintext", plaintext);

        // Extract a challenge scalar from PRF output.
        let r = akem.prf_scalar("challenge-scalar");

        // Calculate the proof scalar, or if the proof scalar is undefined, try again with a
        // different commitment scalar.
        let z = r + d_s;
        if z == Scalar::zero() {
            continue;
        }
        let s = t.expose_secret() * z.invert();

        // Return the shared secret and thw two signature scalars.
        return (k, (r, s));
    }
}

/// Given the recipient's key pair, the sender's public key, the two scalars returned by
/// [encapsulate], and a decryption continuation, return the original plaintext iff the plaintext
/// was originally encapsulated for the given recipient by the given sender.
pub fn decapsulate<F>(
    d_r: &Scalar,
    q_r: &RistrettoPoint,
    q_s: &RistrettoPoint,
    r: &Scalar,
    s: &Scalar,
    decrypt: F,
) -> Option<SecretVec<u8>>
where
    F: FnOnce(SecretVec<u8>) -> Option<SecretVec<u8>>,
{
    // Initialize the protocol.
    let mut akem = Protocol::new("veil.akem");

    // Include the sender and receiver as associated data.
    akem.receive("sender-public-key", q_s.compress().as_bytes());

    // Receive the receiver's public key as cleartext.
    akem.send("receiver-public-key", q_r.compress().as_bytes());

    // Calculate the commitment point and add it as associated data.
    let x = (q_s + (&G * r)) * (d_r * s);
    akem.ad("commitment-point", x.compress().as_bytes());

    // Extract the shared secret.
    let k = Secret::new(akem.prf_vec("shared-secret", KEY_LEN));

    // Use the shared secret to decrypt the ciphertext externally.
    let plaintext = decrypt(k)?;

    // Add the plaintext message as associated data.
    akem.ad("plaintext", plaintext.expose_secret());

    // Extract a challenge scalar from PRF output.
    let r_p = akem.prf_scalar("challenge-scalar");

    // Return the plaintext iff r' == r.
    if r == &r_p {
        Some(plaintext)
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use crate::sres::tests::setup;

    use super::*;

    #[test]
    fn round_trip() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);
        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_eq!(k1.expose_secret(), k2.expose_secret());
            Some(plaintext.to_vec().into())
        });
        assert!(recovered.is_some());
        assert_eq!(plaintext.as_slice(), recovered.unwrap().expose_secret());
    }

    #[test]
    fn wrong_recipient_private_key() {
        let (d_s, q_s, _, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let d_r = Scalar::random(&mut rand::thread_rng());

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_ne!(k1.expose_secret(), k2.expose_secret());
            Some(plaintext.to_vec().into())
        });

        assert!(recovered.is_none());
    }

    #[test]
    fn wrong_recipient_public_key() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let q_r = RistrettoPoint::random(&mut rand::thread_rng());

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_ne!(k1.expose_secret(), k2.expose_secret());
            Some(plaintext.to_vec().into())
        });

        assert!(recovered.is_none());
    }

    #[test]
    fn wrong_sender_public_key() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let q_s = RistrettoPoint::random(&mut rand::thread_rng());

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_ne!(k1.expose_secret(), k2.expose_secret());
            Some(plaintext.to_vec().into())
        });

        assert!(recovered.is_none());
    }

    #[test]
    fn wrong_challenge_scalar() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (_, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let r = Scalar::random(&mut rand::thread_rng());

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_ne!(k1.expose_secret(), k2.expose_secret());
            Some(plaintext.to_vec().into())
        });

        assert!(recovered.is_none());
    }

    #[test]
    fn wrong_proof_scalar() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, _)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let s = Scalar::random(&mut rand::thread_rng());

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_ne!(k1.expose_secret(), k2.expose_secret());
            Some(plaintext.to_vec().into())
        });

        assert!(recovered.is_none());
    }

    #[test]
    fn no_plaintext() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_eq!(k1.expose_secret(), k2.expose_secret());
            None
        });

        assert!(recovered.is_none());
    }

    #[test]
    fn wrong_plaintext() {
        let (d_s, q_s, d_r, q_r) = setup();
        let plaintext = b"ok this is fun";
        let (k1, (r, s)) = encapsulate(&d_s, &q_s, &q_r, plaintext);

        let recovered = decapsulate(&d_r, &q_r, &q_s, &r, &s, |k2| {
            assert_eq!(k1.expose_secret(), k2.expose_secret());
            Some(b"this is terrible".to_vec().into())
        });

        assert!(recovered.is_none());
    }
}
